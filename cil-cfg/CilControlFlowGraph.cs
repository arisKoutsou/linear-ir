using System;
using Mono.Cecil;
using System.Linq;
using System.Collections.Generic;
using Mono.Cecil.Cil;

/// <summary>
///     Represents the control flow graph that is produced for the CIL code inside a method.
/// </summary>
public class CilControlFlowGraph 
{
    private List<Instruction> instructions;

    /// <summary>
    ///     A map from any instruction of the
    ///     method body to it's basic block
    /// </summary>
    private Dictionary<Instruction, CilBasicBlock> branchTargetInstructionDictionary;

    public List<CilBasicBlock> BasicBlocks { get; private set; }

    public CilBasicBlock EntryBasicBlock { get { return BasicBlocks.FirstOrDefault(); } }

    public List<CilBasicBlock> ExitBasicBlocks { 
        get {
            return BasicBlocks
                .Where(x => x.OutBasicBlocks.Count == 0)
                .ToList(); 
        }
     }

    public override String ToString() {
        return String.Join("\n", BasicBlocks);
    }

    public MethodReference Method { get; private set; }

    /// <summary>
    ///     Constructs a Control Flow Graph for the specified module, type and method.    
    /// </summary>
    /// <param name="moduleDefinition"> A Module Definition generated by Cecil library. </param>
    /// <param name="typeName"> Name of a class or any other type. </param>
    /// <param name="methodName"> Name of the method to produce the cfg. </param>
    /// <exception> Throws exception if the method can't be found </exception>
    public CilControlFlowGraph
    (ModuleDefinition moduleDefinition, String typeName, String methodName)
    {
        Method = moduleDefinition.Types
            .First(x => x.Name == typeName)
            .Methods
            .First(x => x.Name == methodName);

        instructions = ((MethodDefinition)Method).Body.Instructions.ToList();
        BasicBlocks = new List<CilBasicBlock>();
        GenerateControlFlowGraph();
    }
    
    private void GenerateControlFlowGraph() {
        FindBranchTargetInstructions();
        ConstructBasicBlocks();
        LinkBasicBlocks();
    }

    /// <summary>
    ///     Finds all the instructions that are the target of a branch, jump etc.
    ///     This can be thought as identifying all the 'labels' that can be found
    ///     in some low level language.
    /// </summary>
    private void FindBranchTargetInstructions() {
        branchTargetInstructionDictionary = instructions
            .Where(x => x.IsControlTransferInstruction())
            .SelectMany(x => x.GetControlTransferInstructionTargets())
            .ToDictionary(k => k, v => (CilBasicBlock)null);
    }

    /// <summary>
    ///     Performs a pass over the method body instructions and identifies the basic blocks.    
    ///     This pass essentially generates the nodes of the graph.
    /// </summary>
    private void ConstructBasicBlocks()
    {
        int basicBlockId = 0;
        var currentBasicBlock = new CilBasicBlock(basicBlockId);
        foreach (var instruction in instructions)
        {
            currentBasicBlock.Instructions.Add(instruction);
            // Update the dictionary for the branch target instructions.
            if (branchTargetInstructionDictionary.ContainsKey(instruction)) {
                branchTargetInstructionDictionary[instruction] = currentBasicBlock;
            }
            if (instruction.Next == null
                || branchTargetInstructionDictionary.ContainsKey(instruction.Next) // Next BB starts at branch target.
                || instruction.IsControlTransferInstruction()) // BB ends at branch.
            {
                // When we reach the end of the Basic block 
                // we add it to the result list.
                BasicBlocks.Add(currentBasicBlock);
                currentBasicBlock = new CilBasicBlock(++basicBlockId);
            }
        }
    }

    private CilBasicBlock FindInstructionBasicBlock(Instruction i) {
        return branchTargetInstructionDictionary[i];
    }

    /// <summary>
    ///     A pass on the basic blocks in order to link them. 
    ///     A link is added by checking the last instruction of the basic block.
    ///     This pass is essentially constructing the edges of the graph.
    /// </summary>
    private void LinkBasicBlocks()
    {
        for (int i = 0; i < BasicBlocks.Count; ++i)
        {
            var currentBasicBlock = BasicBlocks[i];
            var lastInstruction = currentBasicBlock.LastInstruction;
            if (lastInstruction.IsControlTransferInstruction()) {
                var targetInstructions = 
                    lastInstruction.GetControlTransferInstructionTargets();
                var targetBasicBlocks = targetInstructions
                    .Select(FindInstructionBasicBlock)
                    .ToList();
                targetBasicBlocks.ForEach(currentBasicBlock.OutBasicBlocks.Add);
                targetBasicBlocks.ForEach(x => x.InBasicBlocks.Add(currentBasicBlock));
            }
            if (i < BasicBlocks.Count-1 
                && lastInstruction.OpCode != OpCodes.Br
                && !lastInstruction.IsReturnInstruction()) {
                // Fall through.
                var nextBasicBlock = BasicBlocks[i+1];
                currentBasicBlock.OutBasicBlocks.Add(nextBasicBlock);
                currentBasicBlock.NextBasicBlock = nextBasicBlock;
                nextBasicBlock.InBasicBlocks.Add(currentBasicBlock);
            }
            // If ONLY the first if statement is true, 
            // then the last instruction of the BB is a unconditional jump.
            // In that case no fallthrough link is needed.
        }
    }

    
}