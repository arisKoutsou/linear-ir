using System.Collections.Generic;
using Mono.Cecil;
using Mono.Cecil.Cil;

namespace LinearIr.Library
{
  /// <summary>
  ///   This object performs a single pass on the method's instructions
  ///   and generates the linear ir code.
  /// </summary>
  public class ForwardPassLinearIr : AbstractLinearIr
  {
    /// <summary>
    ///   A map from branch targets to the stack size at before
    ///   the instruction is executed.
    /// </summary>
    private Dictionary<Instruction, int> stackSizeAtBranchTarget 
      = new Dictionary<Instruction, int>();

    /// <summary>
    ///   Initializes a new LinearIr object by performing a single forward
    ///   pass to the method definition body instructions.
    /// </summary>
    /// <param name="methodDefinition"> A method definition generated by cecil library. </param>
    public ForwardPassLinearIr(MethodDefinition methodDefinition)
      : base(methodDefinition)
    {
      SetLinearIrInstructions();
    }

    /// <summary>
    ///   Perform a single pass on the method's instructions. 
    ///   Get the linear instruction and place it into it's 
    ///   position in the instruction array.
    /// </summary>
    private void SetLinearIrInstructions()
    {
      // Create an empty array of instructions.
      // The number of instructions does not change across linear-stackbased
      // representations.
      var instructionArray = new LinearIrInstruction[MethodDefinition.Body.Instructions.Count];

      for (int i = 0; i < MethodDefinition.Body.Instructions.Count; i++)
      {
        var stackBasedIrInstruction = MethodDefinition.Body.Instructions[i];
        var linearIrInstruction = GetLinearIrInstructionFrom(stackBasedIrInstruction);
        instructionArray[i] = linearIrInstruction;

        if (stackBasedIrInstruction.IsControlFlowInstruction())
        {
          var targets = stackBasedIrInstruction.GetControlFlowInstructionTargets();
          foreach(var target in targets)
          {
            // Check for duplicates in case of leave instruction.
            if (!stackSizeAtBranchTarget.ContainsKey(target))
              stackSizeAtBranchTarget.Add(target, evaluationStackSize);
          }
        }
        
        // CLI guarantees that the next instruction after
        // an unconditional jump will be executed with an empty stack.
        // Notice that after Throw and Rethrow the stack is not nececerily empty.
        if (!stackBasedIrInstruction.HasFallthroughInstruction())
        {
          if (stackBasedIrInstruction.Next != null &&
              stackSizeAtBranchTarget.ContainsKey(stackBasedIrInstruction.Next))
            evaluationStackSize = stackSizeAtBranchTarget[stackBasedIrInstruction.Next];
          else
            evaluationStackSize = 0;
        }
      }

      Instructions = instructionArray;
    }
  }
}
