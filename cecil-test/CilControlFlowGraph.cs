using System;
using Mono.Cecil;
using System.Linq;
using System.Collections.Generic;
using Mono.Cecil.Cil;

/// <summary>
///     Represents the control flow graph that is produced for the CIL code inside a method.
/// </summary>
public class CilControlFlowGraph 
{
    /// <summary>
    ///     Constructs a Control Flow Graph for the specified module, type and method.    
    /// </summary>
    /// <param name="moduleDefinition"> A Module Definition generated by Cecil library. </param>
    /// <param name="typeName"> Name of a class or any other type. </param>
    /// <param name="methodName"> Name of the method to produce the cfg. </param>
    /// <exception> Throws exception if the method can't be found </exception>
    public CilControlFlowGraph
    (ModuleDefinition moduleDefinition, String typeName, String methodName)
    {
        instructions = moduleDefinition.Types
            .First(x => x.Name == typeName)
            .Methods
            .First(x => x.Name == methodName)
            .Body.Instructions.ToList();
        BasicBlocks = new List<CilBasicBlock>();
        GenerateControlFlowGraph();
    }
    private List<Instruction> instructions;

    /// <summary>
    ///     This basically a map from any instruction of the
    ///     method body to it's basic block
    /// </summary>
    private Dictionary<Instruction, CilBasicBlock> branchTargetInstructionDictionary;

    private void GenerateControlFlowGraph() {
        FindBranchTargetInstructions();
        ConstructBasicBlocks();
        LinkBasicBlocks();
    }

    /// <summary>
    ///     Check's weather an instruction transfers control.
    ///     TODO. This doesn't nessecerilly cover all such instructions.
    ///     i.e: switch, endfinally ...
    /// </summary>
    /// <param name="i"> The instruction to check against. </param>
    /// <returns> A boolean value specifying the result </returns>
    private static bool IsControlTransferInstruction(Instruction i) {
        return i.Operand is Instruction;
    }

    /// <summary>
    ///     Finds all the instructions that are the target of a branch, jump etc.
    ///     This can be thought as identifying all the 'labels' that can be found
    ///     in some low level language.
    /// </summary>
    private void FindBranchTargetInstructions() {
        // TODO. This is a first approach. Only branch instructions have 
        // an instruction object as 'Operand'.
        branchTargetInstructionDictionary = instructions
            .Where(x => IsControlTransferInstruction(x))
            .Select(x => (Instruction)x.Operand)
            .Distinct()
            .ToDictionary(k => k, v => (CilBasicBlock)null);
    }

    /// <summary>
    ///     Performs a pass over the method body instructions and identifies the basic blocks.    
    ///     This pass essentially generates the nodes of the graph.
    /// </summary>
    private void ConstructBasicBlocks()
    {
        int basicBlockId = 0;
        var currentBasicBlock = new CilBasicBlock(basicBlockId);
        foreach (var instruction in instructions)
        {
            currentBasicBlock.Instructions.Add(instruction);
            // Update the dictionary for the branch target instructions.
            if (branchTargetInstructionDictionary.ContainsKey(instruction)) {
                branchTargetInstructionDictionary[instruction] = currentBasicBlock;
            }
            if (instruction.Next == null
                || branchTargetInstructionDictionary.ContainsKey(instruction.Next)
                || IsControlTransferInstruction(instruction))
            {
                // When we reach the end of the Basic block 
                // we add it to the result list.
                BasicBlocks.Add(currentBasicBlock);
                currentBasicBlock = new CilBasicBlock(++basicBlockId);
            }
        }
    }

    private CilBasicBlock FindInstructionBasicBlock(Instruction i) {
        return branchTargetInstructionDictionary[i];
    }

    /// <summary>
    ///     A pass on the basic blocks in order to link them. 
    ///     A link is added by checking the last instruction of the basic block.
    ///     This pass is essentially constructing the edges of the graph.
    /// </summary>
    private void LinkBasicBlocks()
    {
        for (int i = 0; i < BasicBlocks.Count; ++i)
        {
            var currentBasicBlock = BasicBlocks[i];
            var lastInstruction = currentBasicBlock.LastInstruction;
            if (IsControlTransferInstruction(lastInstruction)) {
                // Conditional jump.
                var targetInstruction = lastInstruction.Operand as Instruction;
                var targetBasicBlock = FindInstructionBasicBlock(targetInstruction);
                currentBasicBlock.OutBasicBlocks.Add(targetBasicBlock);
                targetBasicBlock.InBasicBlocks.Add(currentBasicBlock);
            }
            if (i < BasicBlocks.Count-1 && lastInstruction.OpCode != OpCodes.Br) {
                // Fall through.
                var nextBasicBlock = BasicBlocks[i+1];
                currentBasicBlock.OutBasicBlocks.Add(nextBasicBlock);
                currentBasicBlock.NextBasicBlock = nextBasicBlock;
                nextBasicBlock.InBasicBlocks.Add(currentBasicBlock);
            }
            // If ONLY the first if statement is true, 
            // then the last instruction of the BB is a unconditional jump.
            // In that case no fallthrough link is needed.
        }
    }

    public CilBasicBlock EntryBasicBlock { get { return BasicBlocks.FirstOrDefault(); } }

    public List<CilBasicBlock> ExitBasicBlocks { 
        get {
            return BasicBlocks
                .Where(x => x.OutBasicBlocks.Count == 0)
                .ToList(); 
        }
     }

    public List<CilBasicBlock> BasicBlocks { get; private set; }

    public override String ToString() {
        return String.Join('\n', BasicBlocks);
    }
}