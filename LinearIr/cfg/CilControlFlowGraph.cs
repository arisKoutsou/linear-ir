using System;
using Mono.Cecil;
using System.Linq;
using System.Collections.Generic;
using Mono.Cecil.Cil;

namespace LinearIr
{
  ///<summary>
  ///   Represents the control flow graph that is produced for the CIL code inside a method.
  /// </summary>
  public class CilControlFlowGraph
  {
    /// <summary>
    ///   List of method instructions corresponding to the CFG.
    /// </summary>
    private IEnumerable<Instruction> instructions;

    /// <summary>
    ///     A map from any branch target instruction of the
    ///     method body to it's basic block.
    /// </summary>
    private Dictionary<Instruction, CilBasicBlock> branchTargetInstructionDictionary;

    /// <summary>
    ///  Ordered list of the basic blocks as they appear in
    ///  the instruction stream initially.
    /// </summary>
    /// <value></value>
    public List<CilBasicBlock> BasicBlocks { get; private set; }

    /// <summary>
    ///   Entry point of the method. Basic block containing the first instruction of the method.
    /// </summary>
    public CilBasicBlock EntryBasicBlock { get { return BasicBlocks.FirstOrDefault(); } }

    /// <summary>
    ///   All the exit basic blocks. 
    ///   These are the basic blocks that don't have any out basic blocks.
    /// </summary>
    public List<CilBasicBlock> ExitBasicBlocks
    {
      get
      {
        return BasicBlocks
          .Where(x => !x.OutBasicBlocks.Any())
          .ToList();
      }
    }

    /// <summary>
    ///   Get's a string representation of the CFG, which is the concatenation of
    ///   the representation of it's basic blocks.
    /// </summary>
    public override String ToString()
    {
      return String.Join("\n", BasicBlocks);
    }

    /// <summary>
    ///   Method definition associated with this method's CFG.
    /// </summary>
    public MethodDefinition MethodDefinition { get; private set; }

    /// <summary>
    ///     Constructs a Control Flow Graph for the specified module, type and method.    
    /// </summary>
    /// <param name="moduleDefinition"> A Module Definition generated by Cecil library. </param>
    /// <param name="type"> Name of a class or any other type. </param>
    /// <param name="method"> Name of the method to produce the cfg. </param>
    /// <exception> Throws exception if the method can't be found </exception>
    public CilControlFlowGraph(ModuleDefinition moduleDefinition,
      String type, String method)
    {
      var typeDefinition = moduleDefinition.Types
        .FirstOrDefault(x => x.Name == type);
      if (typeDefinition == null)
        throw new ArgumentException(String.Format("Could not find type '{0}'", type));

      var methodDefinition = typeDefinition.Methods
        .First(x => x.Name == method);
      if (methodDefinition == null)
        throw new ArgumentException(String.Format("Could not find method '{0}'", method));

      MethodDefinition = methodDefinition;
      instructions = MethodDefinition.Body
        .Instructions;
      BasicBlocks = new List<CilBasicBlock>();
      GenerateControlFlowGraph();
    }

    /// <summary>
    ///   Constructs a Control Flow Graph for the specified method definition.    
    /// </summary>
    /// <param name="methodDefinition"> A method defintion object. </param>
    public CilControlFlowGraph(MethodDefinition methodDefinition)
    {
      MethodDefinition = methodDefinition;
      instructions = MethodDefinition.Body
        .Instructions;
      BasicBlocks = new List<CilBasicBlock>();
      GenerateControlFlowGraph();
    }

    /// <summary>
    ///   Constructs a Control Flow Graph for the specified module, type and method names.
    /// </summary>
    /// <param name="module"> A module definition </param>
    /// <param name="type"> A type definition </param>
    /// <param name="method"> A method definition </param>
    public CilControlFlowGraph(String module, String type, String method)
      : this(ModuleDefinition.ReadModule(module), type, method)
    {

    }

    /// <summary>
    ///   Performs the 3 steps of the generation algorithm.
    ///   1) Branch target exploration.
    ///   2) Basic Block Construction.
    ///   3) Basic Block Linking.  
    /// </summary>
    private void GenerateControlFlowGraph()
    {
      FindBranchTargetInstructions();
      ConstructBasicBlocks();
      LinkBasicBlocks();
    }

    /// <summary>
    ///     Finds all the instructions that are the target of a branch, jump etc.
    ///     This can be thought as identifying all the 'labels' that can be found
    ///     in some low level language.
    /// </summary>
    private void FindBranchTargetInstructions()
    {
      branchTargetInstructionDictionary = instructions
        .Where(x => x.IsControlFlowInstruction())
        .SelectMany(x => x.GetControlFlowInstructionTargets())
        .Distinct() // leave instructions have the same target.
        .ToDictionary(k => k, v => (CilBasicBlock)null);
    }

    /// <summary>
    ///     Performs a pass over the method body instructions and identifies the basic blocks.    
    ///     This pass essentially generates the nodes of the graph.
    /// </summary>
    private void ConstructBasicBlocks()
    {
      int basicBlockId = 0;
      var currentBasicBlock = new CilBasicBlock(basicBlockId);
      foreach (var instruction in instructions)
      {
        currentBasicBlock.Instructions.Add(instruction);
        // Update the dictionary for the branch target instructions.
        if (branchTargetInstructionDictionary.ContainsKey(instruction))
        {
          branchTargetInstructionDictionary[instruction] = currentBasicBlock;
        }
        if (instruction.Next == null
          || branchTargetInstructionDictionary.ContainsKey(instruction.Next) // Next BB starts at branch target.
          || instruction.IsControlFlowInstruction()) // BB ends at branch.
        {
          // When we reach the end of the Basic block 
          // we add it to the result list.
          BasicBlocks.Add(currentBasicBlock);
          currentBasicBlock = new CilBasicBlock(++basicBlockId);
        }
      }
    }

    /// <summary>
    ///   Get's the basic block of a branch target instruction.
    /// </summary>
    /// <param name="i"> Instruction that is a branch target. </param>
    /// <returns> The corresponding basic block. </returns>
    private CilBasicBlock FindInstructionBasicBlock(Instruction i)
    {
      return branchTargetInstructionDictionary[i];
    }

    /// <summary>
    ///     A pass on the basic blocks in order to link them. 
    ///     A link is added by checking the last instruction of the basic block.
    ///     This pass is essentially constructing the edges of the graph.
    /// </summary>
    private void LinkBasicBlocks()
    {
      for (int i = 0; i < BasicBlocks.Count; ++i)
      {
        var currentBasicBlock = BasicBlocks[i];
        var lastInstruction = currentBasicBlock.LastInstruction;
        if (lastInstruction.IsControlFlowInstruction())
        {
          var targetInstructions =
            lastInstruction.GetControlFlowInstructionTargets();
          var targetBasicBlocks = targetInstructions
            .Select(FindInstructionBasicBlock)
            .ToList();
          targetBasicBlocks.ForEach(currentBasicBlock.OutBasicBlocks.Add);
          targetBasicBlocks.ForEach(x => x.InBasicBlocks.Add(currentBasicBlock));
        }
        if (lastInstruction.HasFallthroughInstruction())
        {
          // Fall through.
          var nextBasicBlock = BasicBlocks[i + 1];
          // The last basic block is always the fallthrough. 
          currentBasicBlock.OutBasicBlocks.Insert(0, nextBasicBlock);
          nextBasicBlock.InBasicBlocks.Add(currentBasicBlock);
        }
      }
    }
  }
}